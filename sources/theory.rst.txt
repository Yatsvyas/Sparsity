Теоретическая часть
===================

Добавляем заголовочные файлы, которые требовались в предыдущей лабораторной работы:

.. code-block:: c++
	
	#include <deal.II/grid/tria.h>
	#include <deal.II/grid/tria_accessor.h>
	#include <deal.II/grid/tria_iterator.h>
	#include <deal.II/grid/grid_generator.h>

Следующий заголовочный файл требуется для связи степеней свободы с вершинами, линиями и ячейками:

.. code-block:: c++
	
	#include <deal.II/dofs/dof_handler.h>

Следующий файл содержит описание билинейного конечного элемента, включая тот факт, что он имеет одну степень свободы на каждой вершине триангуляции, но ни на гранях, ни внутри ячеек:

.. code-block:: c++
	
	#include <deal.II/fe/fe_q.h>

В следующем файле можно найти несколько инструментов для манипулирования степенями свободы:

.. code-block:: c++
	
	#include <deal.II/dofs/dof_tools.h>

Мы будем использовать разреженную матрицу для визуализации паттерна ненулевых записей, возникающих в результате распределения степеней свободы на сетке. Этот класс можно найти здесь:

.. code-block:: c++
	
	#include <deal.II/lac/sparse_matrix.h>

Нам также нужно будет использовать промежуточную структуру паттерна разреженности, которая находится в этом файле :

.. code-block:: c++
	
	#include <deal.II/lac/dynamic_sparsity_pattern.h>

Мы хотим использовать специальный алгоритм для перенумерования степеней свободы. Он объявлен здесь:

.. code-block:: c++
	
	#include <deal.II/dofs/dof_renumbering.h>

Необходимо для вывода C++ :

.. code-block:: c++
	
	#include <fstream>

Импортируем пространство имён deal.ii в глобальную область:

.. code-block:: c++
	
	using namespace dealii;

**Генерация сетки**

Следующая функция создаёт круговую сетку, которая создавалась в предыдущей лабораторной работе. Единственное различие, что в качестве аргумента передаётся ссылка на эту сетку:

.. literalinclude::  static/circularGrid.cpp
	:language: c++
	:encoding: latin-1

**Создание DoFHandler**

До сих пор у нас есть только сетка, то есть некоторая геометрическая (положение вершин) и некоторая топологическая информация (как вершины соединены с линиями, а линии-с ячейками, а также какие ячейки соседствуют с какими другими ячейками). Чтобы использовать численные алгоритмы, нужна некоторая логическая информация в дополнение к этому: мы хотели бы связать числа степеней свободы с каждой вершиной, чтобы позже генерировать матрицы и векторы, которые описывают поле конечных элементов на триангуляции.

Сначала нам нужно создать объект этого класса, а затем передать его объекту DoFHandler, чтобы выделить хранилище для степеней свободы:

.. code-block:: c++
	
	void distribute_dofs(DoFHandler<2> &dof_handler)
	{
		const FE_Q<2> finite_element(1);
		dof_handler.distribute_dofs(finite_element);

С каждой вершиной триангуляции связана функция формы. Предположим, что мы хотим решить что-то вроде уравнения Лапласа, тогда различные элементы матрицы будут интегралами по градиенту каждой пары таких функций формы. Очевидно, что поскольку функции формы ненулевые только в ячейках, смежных с вершиной, с которой они связаны, матричные записи будут ненулевыми только в том случае, если область определения функций формы, связанных с этим столбцом и номерами строк, пересекаются. Это относится только к смежным функциям формы и, следовательно, только к смежным вершинам. Теперь, поскольку вершины пронумерованы более или менее случайным образом приведенной выше функцией (DoFHandler::distribute_dofs), шаблон ненулевых записей в матрице будет несколько неровным, и мы рассмотрим его сейчас.

Сначала нам нужно создать структуру, в которой мы будем хранить места ненулевых элементов. Затем это может быть использовано одним или несколькими объектами разреженной матрицы, которые хранят значения записей в местах, сохраненных этим шаблоном разреженности. Класс, в котором хранятся местоположения - это класс SparsityPattern. Однако оказывается, что у этого класса есть некоторые недостатки, когда мы пытаемся сразу заполнить его: его структуры данных настроены таким образом, что нам нужно иметь оценку максимального количества записей, которое мы можем держать в каждом ряду. В двух измерениях пространства разумные значения для этой оценки доступны через функцию DoFHandler::max_couplings_between_dofs(), но в трех измерениях функция почти всегда сильно переоценивает истинное число, что приводит к большой потере памяти, иногда слишком большой для машины. Чтобы избежать этого, мы используем промежуточный объект типа DynamicSparsityPattern, который использует другую внутреннюю структуру данных и который мы можем позже скопировать в объект SparsityPattern без особых накладных расходов. Чтобы инициализировать эту промежуточную структуру данных, мы должны указать ей размер матрицы, которая в нашем случае будет квадратной с таким же количеством строк и столбцы, так как на сетке есть степени свободы:

.. code-block:: c++
	
	DynamicSparsityPattern dynamic_sparsity_pattern(dof_handler.n_dofs(),
	                                            dof_handler.n_dofs());

Затем мы заполняем этот объект местами, где будут располагаться ненулевые элементы при нынешней нумерации степеней свободы:

.. code-block:: c++
	
	DoFTools::make_sparsity_pattern(dof_handler, dynamic_sparsity_pattern);

Теперь мы готовы создать фактический шаблон разреженности, который мы могли бы позже использовать для нашей матрицы. Он будет просто содержать данные, уже собранные в DynamicSparsityPattern.

.. code-block:: c++
	
	SparsityPattern sparsity_pattern;
	sparsity_pattern.copy_from(dynamic_sparsity_pattern);

Теперь мы можем записать результаты в файл :

.. code-block:: c++
	
	std::ofstream out("sparsity_pattern1.svg");
	sparsity_pattern.print_svg(out);

Результат хранится в файле .svg, где каждая ненулевая запись в матрице соответствует красному квадрату на изображении.

**Перенумерование степеней свободы**

В приведенном выше паттерне разреженности ненулевые элементы простирались довольно далеко от диагонали. Одним из алгоритмов, который добавляет немного сложности в этом направлении, является алгоритм Катхилла-Макки. Мы будем использовать его в следующей функции для перенумерования степеней свободы таким образом, чтобы результирующая картина разреженности была более локализована вокруг диагонали. Единственная интересная часть функции-это первый вызов DoFRenumbering::Cuthill_McKee, остальное, по сути, как и раньше:

.. literalinclude::  static/renumbering.cpp
	:language: c++
	:encoding: latin-1

Ненулевые записи сгруппированы гораздо лучше вокруг диагонали, чем раньше. Этот эффект еще более заметен для более крупных матриц (нынешняя имеет 1260 строк и столбцов, но большие матрицы часто имеют порядка 100 000 строк и столбцов).

**Функция main**

Функция main(), единственное, что она делает - это выделяет и создает триангуляцию, затем создает объект DoFHandler и связывает его с триангуляцией, и, наконец, вызывает над ним две функции:

.. literalinclude::  static/main.cpp
	:language: c++
	:encoding: latin-1